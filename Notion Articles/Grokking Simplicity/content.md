- Side Effects = anything that a function does other than returning a value
- Pure functions = dependent only on their arguments. The same arguments will always produce the same output
	- Functional programming will have side effects and use impure functions
- But those are definitions from academia and not very practical in the industry




- When FP programmers reach a code they first identify what is actions, what is data and what is calculations.
	- Actions: functions that depends on when and how many times they are called (DB insertion, send email)
	- Calculations: functions that yield the same value every time they are called
	- Data: code that is not executable inert and transparent
- All the three of them are good. But Data > Calculations > Actions
- This separation forces the programmer to understand which parts of the code are easy (data and calculations) and which are not (actions)
	- Data and calculations can be used without worries
- Actions can be made of actions, calculations and data (ACD) and so on.
	- We can have a calculation inside an action or a calculation inside a calculation
	- When there is data inside calculations, one should split the calculation in two and the output of one calculation is the input of other
- Data is just data, so it is a guarantee that it will always behave the same
	- Data is facts generated by events
- Decisions are almost always a calculation
- FP is too academic. That is why we have to distill academic and industry ideias indo a functional thinking.
- Most languages do not differentiate actions from calculations and data
- Actions are the actual reason why programs exists
- A FP programmer should not fear actions, instead it should use them as little as possible, keep them small, use them only to interact with the external world




- Stratified design means separating the software into layers where the top one changes frequently and the bottom ones changes sporadically
	- Things at the top are easier to change, sice less code depends on then
	- Things at the bottom are harder to change, but are less likely to.
	- The main layers are: business, domain and tech.




- Timeline diagrams helps the programmer to visualize the order in which actions must be made to meet a goal
- We can cut timelines to optimize the the in which the goal is completed, by doing actions in parallel and coordinate them.




- It is good to always separate the calculations from the actions
	- For instance, in functional programming first one would calculate the shopping list before going shopping
	- So there is a calculation that generates data that then is used by an action
- The fewer things a action does, the better
	- It means that if we can separate out calculations and data from actions we can test these action an calculation better
- Since calculations uses and changes data, we need to run them in order to understand what it does
	- Of course we can run the functions with inputs and check the output, but we cannot tell right away what a function does
	- The only code we can be sure of is data





### Turning actions into calculations

- A function can have explicit and implicit inputs and outputs
	- Explicit: arguments, return value
	- Implicit: change global variable, console.log, write to database (side effects)
- If a function has implicit inputs or outputs, it is an action
- If we remove the implicit components of a action it becomes a calculation
- Implicit outputs make our code not reusable. What if a functions that calculates something and then printed it in the DOM need to be reused somewhere else but we only want the calculation and no the printing?
	- The same goes for implicit inputs, since the input need to be set for the function to be used
	- They are also harder to test, since this inputs and outputs need to be mocked
- **Principle: reduce implicit outputs and inputs the more you can**





### Immutable data

- In FP, it is of great importance that data does not get changed, meaning it should be immutable
	- If data is not immutable reading a variable, for example, become an action instead of a calculation
	- If I read variable (mutable) A now and read it ten minutes from now on, the value could have changed
- For ensuring immutability, we can use a technique called copy-on-write, which is copying the data before changing it
	- Doing that will ensure that the original data stills the same
- One can say that making copies of everything increases the usage of memory, but most functional languages uses structural sharing, which means that copied objects share the structure with the original object.
- Defensive copying = when data is coming in or out your trusted environment (where everything is immutable) you need to ensure this outside data needs to be immutable also
	- If it is not, chances are that after passing by your function it gets changed
	- Defensive copying is meant to prevent data coming in or out to change
	- When it enters our code, we make a deep copy
	- When it leaves our code, we make a deep copy
	- This way we guarantee that if something is going to change, is only the copied data
	- This is also called shared nothing architecture, where components of a software does not share memory
	- Deep copy = no shared structure
- Copy on write (COW) vs Defensive Copy (DC)
	- COW makes shallow copies of data, while DC makes deep copies, which is much more expensive
	- COW is good when exchanging data from or to trusted components, while DC is good when trading data with untrusted sources that we are not sure will apply COW





### Stratified design

- Separate the code into layers
	- Business rules, use cases and language implementations
- For example, we could create layers in our issuing system to separate the business rules of a CTe from its underlying representation (XML)
	- We can create a business layer were functions like addTax or addIssuer could be added and a lower layer that handles the XML manipulation
- If we take a present code and separate its layers, business layers will be using XML manipulation
	- We can identify this when function have too much implementation details
	- Also, the name of the function helps us to identify which layer it belongs to
- When working in a CTe business layer, we don’t care if it is represented as a XML or an object
- When extracting functions because of implementations details, in addition to encapsulating logic we are making it reusable
- Stratified design is not about sweeping implementation details under the carpet (helper functions)
	- The helper functions itself need to be stratified as well
- Abstraction barrier
	- When on layer can use the components of the layer below without having to worry about how it is implemented
	- For example, at Cargon we could have a team that implements the business rules on a CTe an another that implements the transmission of these rules to the government
	- They are good when we don’t actually know how something is going to be implemented later
		- We can create a layers that abstract this unknown implementation and that can be implement when things get clearer without the need to change upper layers
	- Also, it can avoid bugs
		- Implementations usually hide bugs
		- By componentizing implementations, we can reuse it in different places and if a bug is found the fix is going to happen only in one place
		- In short: bugs don’t spread
	- Code below the abstraction does not care where it is going to be used; and code above it does not care about the implementation of details
- Minimal interface
	- A barrier layer should grow as little as possible
	- This is because the bigger a layer gets, the more complex it is to change it if something changes
	- The more functions there are in a layer, the harder it is to keep it in mind
	- Codes that change frequently should be at the top layers, since less or none things depend on them





### First-class functions

- On dynamic vs static-typed languages
- First-class (FC) values are anything that can be stored in a variable and passed as an argument
- Making things FC is good to allow us to move them around the code and apply logic to them (iterate, modify, etc)
- This that are not FC can be wrapped in FC components to make them FC
	- For example, the “+” operator in JS is not FC, wrap in into a function to make it FC

	```javascript
	function sum(a, b){
		return a + b
	}
	```

- High-order (HO) functions are those who take other function as arguments or those that return other functions
	- They allow us to abstract behaviors (such as array iterations) and apply custom behaviors thought the functions passed as arguments
	- There is a refactoring called _replace body with callback_ **that aims to make functions HO**
		- Basically it extracts the behavioral difference between two or more functions
	- The use of high order functions is a good mechanism to avoid repetition
		- If the code has a lot of _for loops_, it is a good idea to create a HO function for it
- Implicit argument in function name
	- This is a code smell where the body of the function determines the behavior of the function, but this behavior could be expressed as an function argument
- Replace body with callback
	- Functions that follows a _before, behavior, after_ pattern, where before and after is equal to all functions and behavior can be passed as a function argument
- 




